<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在macbook上运行大语言模型第二集：使用chatglm.cpp流畅运行清华chatGLM2-6B大模型</title>
    <link href="/2023/09/23/chatglm-cpp/"/>
    <url>/2023/09/23/chatglm-cpp/</url>
    
    <content type="html"><![CDATA[<p>之前一篇介绍了如何在macOS上用cpu运行清华chatGLM大模型，但是也提到模型推理速度非常慢，并不实用。前几天我尝试了llama.cpp项目，效果很惊喜，想起来之前写的运行chatGLM大模型的博客，干脆再写一篇，说说怎么使用chatglm.cpp项目在macOS上流畅运行清华chatGLM2-6B大模型，在cpu上实现比较流畅的聊天体验。chatglm.cpp这个项目实际上脱胎于llama.cpp，这篇写chatglm.cpp主要是为了和上一篇做一个比较直接的速度上的对比，后面可能也会写一篇在mac上运行llama.cpp的博客。</p><p>首先上<a href="https://github.com/li-plus/chatglm.cpp">项目地址</a>：<a href="https://github.com/li-plus/chatglm.cpp">https://github.com/li-plus/chatglm.cpp</a></p><h3 id="下载编译chatGLM-cpp项目"><a href="#下载编译chatGLM-cpp项目" class="headerlink" title="下载编译chatGLM.cpp项目"></a>下载编译chatGLM.cpp项目</h3><p>首先clone项目到本地：<br><code>git clone --recursive https://github.com/li-plus/chatglm.cpp.git &amp;&amp; cd chatglm.cpp</code></p><p>使用cmake编译:<br><code>cmake -B build &amp;&amp; cmake --build build -j --config Release</code></p><p>Apple Silicon 用户可以开启Metal支持，这样可以使用GPU进行推理，速度会快很多：<br><code>cmake -B build -DGGML_METAL=ON &amp;&amp; cmake --build build -j</code></p><h3 id="准备chatGLM2-6B模型"><a href="#准备chatGLM2-6B模型" class="headerlink" title="准备chatGLM2-6B模型"></a>准备chatGLM2-6B模型</h3><p><code>python3 chatglm_cpp/convert.py -i THUDM/chatglm2-6b -t q8_0 -o chatglm2-ggml.bin</code><br>这时会自动下载chatglm2-6b模型，下载完成后会自动转换模型，进行8位量化，完成后会在当前目录下生成<code>chatglm2-ggml.bin</code>文件。注意这个过程需要把整个模型加载到内存里，内存占用很大，我16G内存的mbp在运行的时候出现了内存不够用进程被kill的情况，关掉了其他的一些应用才成功运行。</p><p>这里可选的模型包括：</p><ul><li>ChatGLM-6B: THUDM&#x2F;chatglm-6b, THUDM&#x2F;chatglm-6b-int8, THUDM&#x2F;chatglm-6b-int4</li><li>ChatGLM2-6B: THUDM&#x2F;chatglm2-6b, THUDM&#x2F;chatglm2-6b-int4</li><li>CodeGeeX2: THUDM&#x2F;codegeex2-6b, THUDM&#x2F;codegeex2-6b-int4</li><li>Baichuan-13B: baichuan-inc&#x2F;Baichuan-13B-Chat</li><li>Baichuan2-13B: baichuan-inc&#x2F;Baichuan2-13B-Chat<br>可选的量化模式包括：</li><li>q4_0: 4位整数量化，fp16缩放</li><li>q4_1: 4位整数量化，fp16缩放和最小值</li><li>q5_0: 5位整数量化，fp16缩放</li><li>q5_1: 5位整数量化，fp16缩放和最小值</li><li>q8_0: 8位整数量化，fp16缩放</li><li>f16: 半精度浮点数权重，不进行量化</li><li>f32: 单精度浮点数权重，不进行量化<br>根据chatGLM.cpp项目说明，对于LoRA模型，可以添加<code>-l &lt;lora_model_name_or_path&gt;</code>flag将LoRA权重合并到基本模型中。</li></ul><h3 id="开始聊天！"><a href="#开始聊天！" class="headerlink" title="开始聊天！"></a>开始聊天！</h3><p><code>./build/bin/main -m /Users/liangsidi/Desktop/chatglm2-ggml.bin -i</code> 进入交互模式，开始聊天！可以发现和之前几十秒蹦出来一个单词比，得益于chatGLM.cpp的高效实现以及模型量化，这个模型的推理速度非常快，仅用CPU也可以接近网页版chatGPT的生成速度（当然模型的规模比chatGPT小太多了）。内存占用也很低，只有几百M，可以说达到了实用水平。这下在mac上运行大模型终于不是标题党了！<br><img src="/2023/09/23/chatglm-cpp/screenshot.png" alt="运行效果"></p>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中文</tag>
      
      <tag>机器学习</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Getting Started with NodeMCU on macOS - 在macOS上的NodeMCU上手笔记</title>
    <link href="/2023/09/11/nodemcu/"/>
    <url>/2023/09/11/nodemcu/</url>
    
    <content type="html"><![CDATA[<h3 id="为了方便过审投放谷歌广告，这个笔记用英文撰写，划到下面有chatGPT提供的中文翻译版"><a href="#为了方便过审投放谷歌广告，这个笔记用英文撰写，划到下面有chatGPT提供的中文翻译版" class="headerlink" title="为了方便过审投放谷歌广告，这个笔记用英文撰写，划到下面有chatGPT提供的中文翻译版"></a><em>为了方便过审投放谷歌广告，这个笔记用英文撰写，划到下面有chatGPT提供的中文翻译版</em></h3><h3 id="Building-the-firmware"><a href="#Building-the-firmware" class="headerlink" title="Building the firmware"></a>Building the firmware</h3><p>As only the application are concerned, we can use the online firmware building service at <a href="http://nodemcu-build.com/">http://nodemcu-build.com</a> to get the firmware. It’s quite straightforward to build the firmware on this website, by just selecting the modules to be included. However, it won’t work if too many modules are selected.</p><h3 id="Flashing-the-firmware"><a href="#Flashing-the-firmware" class="headerlink" title="Flashing the firmware"></a>Flashing the firmware</h3><p>First make sure that the usb serial firmware is properly installed on the system.<br>I used this tool to flash the firmware:<br><a href="https://github.com/marcelstoer/nodemcu-pyflasher">https://github.com/marcelstoer/nodemcu-pyflasher</a><br>baudrate: 115200 (others might also work), dual IO, …</p><h2 id="Using-NodeMCU-Tool"><a href="#Using-NodeMCU-Tool" class="headerlink" title="Using NodeMCU-Tool"></a>Using NodeMCU-Tool</h2><p>NodeMCU-Tool: <a href="https://github.com/andidittrich/NodeMCU-Tool">https://github.com/andidittrich/NodeMCU-Tool</a><br><em>Before installing NodeMCU-Tool, make sure that you have  Node.js &gt;&#x3D; 7.6 installed on your system.</em></p><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p><code>sudo npm install nodemcu-tool -g</code><br>This will install NodeMCU-Tool <strong>globally</strong> on your system.</p><h3 id="Verifying-the-installation"><a href="#Verifying-the-installation" class="headerlink" title="Verifying the installation"></a>Verifying the installation</h3><p><code>nodemcu-tool --version</code></p><h3 id="Creating-the-file-system"><a href="#Creating-the-file-system" class="headerlink" title="Creating the file system"></a>Creating the file system</h3><p><code>nodemcu-tool mkfs --port=/dev/tty.wchusbserial14410 --connection-delay 300 --baud 115200</code><br>outputs:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">(<span class="hljs-keyword">node</span><span class="hljs-title">:13754</span>) Warning: Accessing non-existent <span class="hljs-keyword">property</span><span class="hljs-title"> </span>&#x27;padLevels&#x27; of module exports inside circular dependency<br>(Use `<span class="hljs-keyword">node</span> <span class="hljs-title">--trace-warnings</span> ...` to show where the warning was created)<br>[NodeMCU-Tool]~ Connected<br>[device]      ~ Arch: esp8266 | <span class="hljs-keyword">Version</span>: <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span> | ChipID: <span class="hljs-number">0</span>x2aecbf | FlashID: <span class="hljs-number">0</span>x1640c8<br>[NodeMCU-Tool]~ Uploading <span class="hljs-string">&quot;helloworld.lua&quot;</span> &gt;&gt; <span class="hljs-string">&quot;helloworld.lua&quot;</span>...<br>[connector]   ~ Transfer-Mode: hex<br>[NodeMCU-Tool]~ File Transfer complete!<br>[NodeMCU-Tool]~ disconnecting<br><br></code></pre></td></tr></table></figure><h3 id="Uploading-code"><a href="#Uploading-code" class="headerlink" title="Uploading code"></a>Uploading code</h3><p><code>nodemcu-tool upload --port=/dev/tty.wchusbserial14410 --connection-delay 300 --baud 115200 helloworld.lua </code><br>outputs:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">(<span class="hljs-keyword">node</span><span class="hljs-title">:13754</span>) Warning: Accessing non-existent <span class="hljs-keyword">property</span><span class="hljs-title"> </span>&#x27;padLevels&#x27; of module exports inside circular dependency<br>(Use `<span class="hljs-keyword">node</span> <span class="hljs-title">--trace-warnings</span> ...` to show where the warning was created)<br>[NodeMCU-Tool]~ Connected<br>[device]      ~ Arch: esp8266 | <span class="hljs-keyword">Version</span>: <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span> | ChipID: <span class="hljs-number">0</span>x2aecbf | FlashID: <span class="hljs-number">0</span>x1640c8<br>[NodeMCU-Tool]~ Uploading <span class="hljs-string">&quot;helloworld.lua&quot;</span> &gt;&gt; <span class="hljs-string">&quot;helloworld.lua&quot;</span>...<br>[connector]   ~ Transfer-Mode: hex<br>[NodeMCU-Tool]~ File Transfer complete!<br>[NodeMCU-Tool]~ disconnecting<br><br></code></pre></td></tr></table></figure><h3 id="Running-the-helloworld"><a href="#Running-the-helloworld" class="headerlink" title="Running the helloworld"></a>Running the helloworld</h3><p><code>nodemcu-tool run helloworld.lua --port=/dev/tty.wchusbserial14410 --connection-delay 300 --baud 115200</code><br>outputs:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">(node:13764) Warning: Accessing non-existent property &#x27;padLevels&#x27; of module exports inside circular dependency<br>(Use `node --trace-warnings ...` to show where the warning was created)<br>[NodeMCU-Tool]~ Connected<br>[device]      ~ Arch: esp8266 |<span class="hljs-string"> Version: 3.0.0 </span>|<span class="hljs-string"> ChipID: 0x2aecbf </span>|<span class="hljs-string"> FlashID: 0x1640c8</span><br><span class="hljs-string">[device]      ~ Running &quot;helloworld.lua&quot;</span><br><span class="hljs-string">[device]      ~ &gt;-----------------------------&gt;</span><br><span class="hljs-string">Hello World!</span><br><span class="hljs-string"></span>|<span class="hljs-string">---</span>|<br>|<span class="hljs-string"> H </span>|<br>|<span class="hljs-string"> E </span>|<br>|<span class="hljs-string"> L </span>|<br>|<span class="hljs-string"> L </span>|<br>|<span class="hljs-string"> O </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string"> W </span>|<br>|<span class="hljs-string"> O </span>|<br>|<span class="hljs-string"> R </span>|<br>|<span class="hljs-string"> L </span>|<br>|<span class="hljs-string"> D </span>|<br>|<span class="hljs-string">---</span>|<br>YEAH!!! HELLO WORLD!!!<br>String: Lorem ipsum dolor sit amet, consetetur sadipscing elitr<br>[device]      ~ &gt;-----------------------------&gt;<br>[NodeMCU-Tool]~ disconnecting<br><br></code></pre></td></tr></table></figure><h3 id="To-be-continued-LUA-programming"><a href="#To-be-continued-LUA-programming" class="headerlink" title="To be continued: LUA programming"></a>To be continued: LUA programming</h3><h3 id="构建固件"><a href="#构建固件" class="headerlink" title="构建固件"></a>构建固件</h3><p>由于只关心应用程序，我们可以使用在线固件构建服务 <a href="http://nodemcu-build.com/">http://nodemcu-build.com</a> 来获取固件。在这个网站上构建固件非常简单，只需选择要包含的模块即可。但是，如果选择了太多模块，它可能不起作用。</p><h3 id="刷写固件"><a href="#刷写固件" class="headerlink" title="刷写固件"></a>刷写固件</h3><p>首先确保 USB 串行固件已正确安装在系统上。<br>我使用了这个工具来刷写固件：<br><a href="https://github.com/marcelstoer/nodemcu-pyflasher">https://github.com/marcelstoer/nodemcu-pyflasher</a><br>波特率：115200（其他波特率也可能适用），双重 IO，…</p><h2 id="使用-NodeMCU-Tool"><a href="#使用-NodeMCU-Tool" class="headerlink" title="使用 NodeMCU-Tool"></a>使用 NodeMCU-Tool</h2><p>NodeMCU-Tool：<a href="https://github.com/andidittrich/NodeMCU-Tool">https://github.com/andidittrich/NodeMCU-Tool</a><br><em>在安装 NodeMCU-Tool 之前，请确保您的系统上已安装 Node.js &gt;&#x3D; 7.6。</em></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo npm install nodemcu-tool -g</code><br>这将在您的系统上<strong>全局</strong>安装 NodeMCU-Tool。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p><code>nodemcu-tool --version</code></p><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p><code>nodemcu-tool mkfs --port=/dev/tty.wchusbserial14410 --connection-delay 300 --baud 115200</code><br>输出：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">(node:<span class="hljs-number">13754</span>) 警告: 在循环依赖关系内部访问模块导出的不存在的属性 <span class="hljs-string">&#x27;padLevels&#x27;</span><br>(使用 <span class="hljs-string">`node --trace-warnings ...`</span> 来显示警告的创建位置)<br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 已连接<br>[device]      ~ 架构：esp8266 | 版本：<span class="hljs-number">3.0</span><span class="hljs-number">.0</span> | 芯片<span class="hljs-symbol">ID</span>：<span class="hljs-number">0x2aecbf</span> | <span class="hljs-symbol">FlashID</span>：<span class="hljs-number">0x1640c8</span><br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 上传 <span class="hljs-string">&quot;helloworld.lua&quot;</span> &gt;&gt; <span class="hljs-string">&quot;helloworld.lua&quot;</span>...<br>[connector]   ~ 传输模式：hex<br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 文件传输完成！<br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 断开连接<br><br></code></pre></td></tr></table></figure><h3 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h3><p><code>nodemcu-tool upload --port=/dev/tty.wchusbserial14410 --connection-delay 300 --baud 115200 helloworld.lua </code><br>输出：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">(node:<span class="hljs-number">13754</span>) 警告: 在循环依赖关系内部访问模块导出的不存在的属性 <span class="hljs-string">&#x27;padLevels&#x27;</span><br>(使用 <span class="hljs-string">`node --trace-warnings ...`</span> 来显示警告的创建位置)<br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 已连接<br>[device]      ~ 架构：esp8266 | 版本：<span class="hljs-number">3.0</span><span class="hljs-number">.0</span> | 芯片<span class="hljs-symbol">ID</span>：<span class="hljs-number">0x2aecbf</span> | <span class="hljs-symbol">FlashID</span>：<span class="hljs-number">0x1640c8</span><br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 上传 <span class="hljs-string">&quot;helloworld.lua&quot;</span> &gt;&gt; <span class="hljs-string">&quot;helloworld.lua&quot;</span>...<br>[connector]   ~ 传输模式：hex<br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 文件传输完成！<br>[<span class="hljs-symbol">NodeMCU</span>-<span class="hljs-symbol">Tool</span>]~ 断开连接<br><br></code></pre></td></tr></table></figure><h3 id="运行-helloworld"><a href="#运行-helloworld" class="headerlink" title="运行 helloworld"></a>运行 helloworld</h3><p><code>nodemcu-tool run helloworld.lua --port=/dev/tty.wchusbserial14410 --connection-delay 300 --baud 115200</code><br>输出：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">(node:13764) 警告: 在循环依赖关系内部访问模块导出的不存在的属性 &#x27;padLevels&#x27;<br>(使用 `node --trace-warnings ...` 来显示警告的创建位置)<br>[NodeMCU-Tool]~ 已连接<br>[device]      ~ 架构：esp8266 |<span class="hljs-string"> 版本：3.0.0 </span>|<span class="hljs-string"> 芯片ID：0x2aecbf </span>|<span class="hljs-string"> FlashID：0x1640c8</span><br><span class="hljs-string">[device]      ~ 正在运行 &quot;helloworld.lua&quot;</span><br><span class="hljs-string">[device]      ~ &gt;-----------------------------&gt;</span><br><span class="hljs-string">Hello World!</span><br><span class="hljs-string"></span>|<span class="hljs-string">---</span>|<br>|<span class="hljs-string"> H </span>|<br>|<span class="hljs-string"> E </span>|<br>|<span class="hljs-string"> L </span>|<br>|<span class="hljs-string"> L </span>|<br>|<span class="hljs-string"> O </span>|<br>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<br>|<span class="hljs-string"> W </span>|<br>|<span class="hljs-string"> O </span>|<br>|<span class="hljs-string"> R </span>|<br>|<span class="hljs-string"> L </span>|<br>|<span class="hljs-string"> D </span>|<br>|<span class="hljs-string">---</span>|<br>YEAH!!! HELLO WORLD!!!<br>String: Lorem ipsum dolor sit amet, consetetur sadipscing elitr<br>[device]      ~ &gt;-----------------------------&gt;<br>[NodeMCU-Tool]~ 断开连接<br><br></code></pre></td></tr></table></figure><h3 id="未完待续：LUA-编程"><a href="#未完待续：LUA-编程" class="headerlink" title="未完待续：LUA 编程"></a>未完待续：LUA 编程</h3>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式开发</tag>
      
      <tag>中文</tag>
      
      <tag>English</tag>
      
      <tag>NodeMCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在mac上用cpu运行清华chatGLM-6B大模型，拥有自己的chatGPT！</title>
    <link href="/2023/04/05/chatglm-mac-cpu/"/>
    <url>/2023/04/05/chatglm-mac-cpu/</url>
    
    <content type="html"><![CDATA[<p>用mac也可以部署运行大模型！标题其实有些夸大的成分，因为用cpu进行模型推理实在是太慢了，没有什么实际意义，但是也算是一种体验大模型的方式吧。</p><p>先上一段官方介绍：</p><blockquote><p>ChatGLM-6B 是一个开源的、支持中英双语的对话语言模型，基于 General Language Model (GLM) 架构，具有 62 亿参数。结合模型量化技术，用户可以在消费级的显卡上进行本地部署（INT4 量化级别下最低只需 6GB 显存）。 ChatGLM-6B 使用了和 ChatGPT 相似的技术，针对中文问答和对话进行了优化。经过约 1T 标识符的中英双语训练，辅以监督微调、反馈自助、人类反馈强化学习等技术的加持，62 亿参数的 ChatGLM-6B 已经能生成相当符合人类偏好的回答.</p></blockquote><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><p>首先把chatGLM的代码clone到本地：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/THUDM/</span>ChatGLM-<span class="hljs-number">6</span>B.git           <br>cd ChatGLM-<span class="hljs-number">6</span>B                        <br></code></pre></td></tr></table></figure><p>然后将chatGLM-6B的权重下载到本地：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git lfs install<br>git clone https:<span class="hljs-regexp">//</span>huggingface.co<span class="hljs-regexp">/THUDM/</span>chatglm-<span class="hljs-number">6</span>b/<br></code></pre></td></tr></table></figure><p>下载好之后，用pip安装依赖：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> -r requirements.txt<br>pip3 <span class="hljs-keyword">install</span> gradio    <br></code></pre></td></tr></table></figure><p>都安装好之后，需要对代码进行一些修改才能让其在mac上顺利运行。<br>这次我主要尝试运行cli_demo.py。我这里将其复制为my_cli_demo.py，第6、7行做如下修改：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tokenizer</span> = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;THUDM/chatglm-6b&quot;</span>, trust_remote_code=<span class="hljs-literal">True</span>)<br><span class="hljs-attr">model</span> = AutoModel.from_pretrained(<span class="hljs-string">&quot;THUDM/chatglm-6b&quot;</span>, trust_remote_code=<span class="hljs-literal">True</span>).half().cuda()<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tokenizer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AutoTokenizer</span>.</span></span>from<span class="hljs-constructor">_pretrained(<span class="hljs-string">&quot;./chatglm-6b&quot;</span>, <span class="hljs-params">trust_remote_code</span>=True)</span><br>model = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AutoModel</span>.</span></span>from<span class="hljs-constructor">_pretrained(<span class="hljs-string">&quot;./chatglm-6b&quot;</span>, <span class="hljs-params">trust_remote_code</span>=True)</span>.<span class="hljs-built_in">float</span><span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><p>如果是M1或者M2的mac，可以改成下面这样来启用GPU推理（前提是安装了PyTorch-Nightly，可参考<a href="https://developer.apple.com/metal/pytorch/">Apple 官方教程</a>）：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">model</span> = AutoModel.from_pretrained(<span class="hljs-string">&quot;./chatglm-6b&quot;</span>, trust_remote_code=<span class="hljs-literal">True</span>).half().to(<span class="hljs-string">&#x27;mps&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后找到<code>chatglm-6b</code>下<code>modeling_chatglm.py</code>, 注释掉1394行至1404行：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean">#<span class="hljs-keyword">from</span> .quantization <span class="hljs-keyword">import</span> quantize<br><br>#<span class="hljs-keyword">if</span> self.quantized:<br>#    logger.info(<span class="hljs-string">&quot;Already quantized.&quot;</span>)<br>#    return self<br><br>#self.quantized = <span class="hljs-literal">True</span><br><br>#self.config.quantization_bit = bits<br><br>#self.transformer = quantize(self.transformer, bits, empty_init=empty_init, **kwargs)<br></code></pre></td></tr></table></figure><p>万事俱备！<code>python3 my_cli_demo.py</code>运行！我这里是16GB内存，勉强够用，一个回复大概要等10分钟左右。可能会出现内存不足的情况，可以把其他占内存的应用关掉再试试。<br><img src="/2023/04/05/chatglm-mac-cpu/1.png" alt="运行效果，这里遇到了内存不足的问题"><br><img src="/2023/04/05/chatglm-mac-cpu/4.png" alt="内存占用情况，大概占用了23G左右的内存"><br><img src="/2023/04/05/chatglm-mac-cpu/3.png" alt="运行效果"></p>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中文</tag>
      
      <tag>机器学习</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BNO055 OpenMV上手初体验：第一次用这么高级的IMU传感器</title>
    <link href="/2023/03/27/bno055/"/>
    <url>/2023/03/27/bno055/</url>
    
    <content type="html"><![CDATA[<blockquote><p>BNO055是一款由Bosch Sensortec开发的9轴惯性传感器，能够提供三轴加速度计、三轴陀螺仪和三轴磁力计的数据。该传感器还集成了一个ARM Cortex-M0处理器和一个传感器数据融合引擎，用于处理和融合来自多个传感器的数据，并提供稳定和准确的定位、方向和姿态信息。<br>BNO055可以通过I2C和SPI接口与各种微控制器和单板计算机通信，支持多种输出模式和数据格式。该传感器还提供自动校准和自适应的传感器校准功能，可以显著提高系统精度和可靠性。<br>由于其高度集成的设计和先进的数据融合算法，BNO055广泛应用于航空航天、机器人、虚拟现实、智能家居和移动设备等领域，是一款性能稳定、易于使用和可靠性高的惯性传感器。<br>—— ChatGPT</p></blockquote><p>这学期TDPS课程做巡线小车，其中一部分要求是小车顺着一条砖线开一段。实地考察后发现砖块和周围地面颜色不太好区分，于是决定在openMV机器视觉算法的基础上加一个惯导模块辅助导航，保证导航准确率。首先尝试了一下手头的几块钱一块的廉价传感器BMI160，但发现BMI160缺乏地磁传感器，能起到的辅助作用有限，再一看发现openMV官方推荐的传感器bno055能满足我们的需求。BNO055确实是高级玩意，甚至自带了一个MCU，价格大概一百多块钱。也有更便宜的解决方案，但是都需要自己适配，而BNO055已经有官方提供的第三方库可以用了，于是组内讨论之后决定直接一步到位上BNO055。<br><img src="/2023/03/27/bno055/SEN0374.jpg" alt="图摘自官方wiki"><br>采购是另外一个同学负责，板子到货之后发现购买的是dfrobot家的SEN0374芯片，提供了以下几个接口（翻译自官方wiki）：</p><table><thead><tr><th>丝印</th><th>功能描述</th></tr></thead><tbody><tr><td>VCC</td><td>+</td></tr><tr><td>GND</td><td>-</td></tr><tr><td>SCL</td><td>I2C 时钟</td></tr><tr><td>SDA</td><td>I2C 数据</td></tr><tr><td>INT</td><td>中断接口</td></tr><tr><td>BOOT</td><td>LEAD模式选择接口</td></tr><tr><td>PS1</td><td>协议选择接口1</td></tr><tr><td>PS2</td><td>协议选择接口2</td></tr><tr><td>BL-IND</td><td>Lead Program Guide</td></tr><tr><td>RST</td><td>重制</td></tr><tr><td>ADDR</td><td>I2C 地址选择</td></tr></tbody></table><p>PS1 和 PS2的具体功能如下：（默认均为0）（翻译自官方wiki）：</p><table><thead><tr><th>PS1</th><th>PS2</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>标准&#x2F;快速I2C</td></tr><tr><td>0</td><td>1</td><td>HID OVER I2C</td></tr><tr><td>1</td><td>0</td><td>UART</td></tr><tr><td>1</td><td>1</td><td>预留</td></tr></tbody></table><p>看着挺花哨，实际使用的时候用I2C通信最少只用接VCC、GND、SCL、SDA四个脚就够了。SCL、SDA分别接上OpenMV的P4、P5，VCC接3V3，GND接地。传感器I2C默认地址是0X28（用官方提供的第三方库其实也不用管）。查阅datasheet发现这个芯片支持很多种工作模式，包括不同的功耗模式和不同的传感器模式，对于小车来说只需要用普通功耗模式和使用全部传感器的模式，输出传感器智能融合之后的数据，所以这些也都先不管。先看看能不能顺利拿到我们最关心的磁航向数据，直接上修改过的官方例程：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs leaf">from machine import Pin, I2C<br>from bno055 import BNO055, AXIS_P7<br>import time<br>i2c = I2C(sda=Pin(&#x27;P5&#x27;), scl=Pin(&#x27;P4&#x27;), freq=400000)<br>imu = BNO055(i2c)<br>while True:<br>    #temperature = imu.temperature()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">temperature</span>: ℃&#x27;,<span class="hljs-variable">temperature</span>)</span></span><br>    yaw, roll, pitch = imu.euler()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">yaw</span>, <span class="hljs-variable">roll</span>, <span class="hljs-variable">pitch</span>: °&#x27;, <span class="hljs-variable">yaw</span>, <span class="hljs-variable">roll</span>, <span class="hljs-variable">pitch</span>)</span></span><br>    w, x, y, z = imu.quaternion()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">Quaternion</span>:&#x27;, <span class="hljs-variable">w</span>, <span class="hljs-variable">x</span>, <span class="hljs-variable">y</span>, <span class="hljs-variable">z</span>)</span></span><br>    x, y, z = imu.accelerometer()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">Accelerometer</span> (<span class="hljs-variable">m</span>/<span class="hljs-variable">s</span>^2)</span></span>:&#x27;, x, y, z)<br>    x, y, z = imu.magnetometer()<br>    print(&#x27;Magnetometer (microteslas):&#x27;, x, y, z)<br>    x, y, z = imu.gyroscope()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">Gyroscope</span> (<span class="hljs-variable">deg</span>/<span class="hljs-variable">sec</span>)</span></span>:&#x27;, x, y, z)<br>    x, y, z = imu.linear_acceleration()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">Linear</span> <span class="hljs-variable">acceleration</span> (<span class="hljs-variable">m</span>/<span class="hljs-variable">s</span>^2)</span></span>&#x27;, x, y, z)<br>    x, y, z = imu.gravity()<br>    <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">print</span><span class="hljs-params">(&#x27;<span class="hljs-variable">Gravity</span> (<span class="hljs-variable">m</span>/<span class="hljs-variable">s</span>^2)</span></span>:&#x27;, x, y, z)<br>    time.sleep_ms(100)<br><br></code></pre></td></tr></table></figure><p>上电，简单摇晃传感器对地磁传感器进行校准后查看输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">27</span>.<span class="hljs-number">375</span> <span class="hljs-number">18</span>.<span class="hljs-number">6875</span> -<span class="hljs-number">17</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">27</span>.<span class="hljs-number">375</span> <span class="hljs-number">18</span>.<span class="hljs-number">25</span> -<span class="hljs-number">18</span>.<span class="hljs-number">1875</span><br><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">28</span>.<span class="hljs-number">0625</span> <span class="hljs-number">18</span>.<span class="hljs-number">25</span> -<span class="hljs-number">16</span>.<span class="hljs-number">5625</span><br><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">27</span>.<span class="hljs-number">75</span> <span class="hljs-number">18</span>.<span class="hljs-number">0</span> -<span class="hljs-number">16</span>.<span class="hljs-number">5625</span><br><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">28</span>.<span class="hljs-number">0625</span> <span class="hljs-number">18</span>.<span class="hljs-number">25</span> -<span class="hljs-number">16</span>.<span class="hljs-number">1875</span><br><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">27</span>.<span class="hljs-number">75</span> <span class="hljs-number">17</span>.<span class="hljs-number">5625</span> -<span class="hljs-number">18</span>.<span class="hljs-number">1875</span><br><span class="hljs-attribute">Magnetometer</span> (microteslas): -<span class="hljs-number">28</span>.<span class="hljs-number">5</span> <span class="hljs-number">18</span>.<span class="hljs-number">6875</span> -<span class="hljs-number">17</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>顺利拿到了我们需要的数据。</p><p>后续装车可能需要注意一下传感器校准的问题，目前的模式下启用了快速校准模式，但可能也需要随机移动传感器对其进行校准。Datasheet提到可以校准一次后存储校准数据以便以后上电之后使用，装车之后再看看有没有这个需要。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式开发</tag>
      
      <tag>OpenMV</tag>
      
      <tag>中文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SynthStrip对任意序列(T1、T2、FLAIR、T1CE等)脑部MRI图像进行去颅骨处理</title>
    <link href="/2023/03/18/SynthStrip/"/>
    <url>/2023/03/18/SynthStrip/</url>
    
    <content type="html"><![CDATA[<p>目前正在做的项目需要对T1, T2, FLAIR 和T1CE四种序列的脑部MRI图像进行预处理，主要是归一化和去颅骨。然而，操作中发现FreeSurfer的去颅骨算法只适用于T1，并不适用于其他几个序列，切出来的结果非常混乱。经过一段时间搜索后发现了一个叫<a href="https://pubmed.ncbi.nlm.nih.gov/35842095/">SynthStrip</a>[1]的去颅骨方法，应用神经网络将图像中的颅骨部分去除，可以对任意序列的脑部图像进行去颅骨。<br><img src="/2023/03/18/SynthStrip/img1.png" alt="SynthStrip论文"><br>访问官网，发现这个工具已经在 v7.3.0 release中被整合进FreeSurfer中，且在2023-02-14这天的freesurfer release中修复了一个已知的问题。二话不说，直接下载安装dev版本的freesurfer（<a href="https://surfer.nmr.mgh.harvard.edu/pub/dist/freesurfer/dev/">官方下载地址</a>），思路就是先完成去颅骨之前的处理步骤，然后改用新版FreeSurfer软件包里集成的SynthStrip工具进行去颅骨。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">recon-all -s .<span class="hljs-regexp">/subjects/</span>bratsexample -i Brats17_CBICA_ABO_1_t2.nii.gz -autorecon1 -noskullstrip<br>mri_synthstrip -i .<span class="hljs-regexp">/subjects/</span>bratsexample<span class="hljs-regexp">/mri/</span>T1.mgz -o <span class="hljs-regexp">/preprocess/</span>sub<span class="hljs-regexp">/mri/</span>strip.mgz<br>mri_convert .<span class="hljs-regexp">/subjects/</span>bratsexample<span class="hljs-regexp">/mri/</span>strip.mgz <span class="hljs-regexp">/preprocess/</span>sub<span class="hljs-regexp">/mri/</span>Brats17_CBICA_ABO_1_t2_preprocessed.nii.gz<br></code></pre></td></tr></table></figure><p><img src="/2023/03/18/SynthStrip/img2.png" alt="T2、FLAIR、T1CE处理效果">  </p><p>可以看到，使用SynthStrip工具可以正确去除T1、T2、FLAIR、T1CE四个序列MRI图像中的颅骨部分，解决了原有工具难以对T2、FLAIR、T1CE自动去颅骨的问题。  </p><p>[1] Hoopes A, Mora JS, Dalca AV, Fischl B, Hoffmann M. SynthStrip: skull-stripping for any brain image. Neuroimage. 2022 Oct 15;260:119474. doi: 10.1016&#x2F;j.neuroimage.2022.119474. Epub 2022 Jul 13. PMID: 35842095; PMCID: PMC9465771.</p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中文</tag>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 - 在macOS上使用FreeSurfer对脑部MRI图像进行预处理</title>
    <link href="/2023/03/17/freesurfer/"/>
    <url>/2023/03/17/freesurfer/</url>
    
    <content type="html"><![CDATA[<p><a href="http://freesurfer.net/">FreeSurfer</a>是一个开源的软件套件，集成了许多知名工具（如ANTs、FSL等），被广泛用于处理和分析人脑MRI成像数据，且目前开发团队仍然在对其进行维护和更新。<code>recon-all</code> 是FreeSurfer的核心指令，用于完成FreeSurfer皮质重建的部分或全部过程。<code>recon-all</code> 大概有30多个步骤，并提供了只完成其中某些步骤的选项。我使用FreeSurfer主要是利用它前面的几个预处理步骤，包括强度归一化、映射到标准脑、以及去颅骨。<br>有一个细节，就是根据FreeSurfer的文档， <em><strong>FreeSurfer（中的许多工具）只能用于处理T1序列的图像</strong></em> 。实际操作中发现FreeSurfer的去颅骨算法是根据颜色的不同进行去颅骨，把T2的图像送进去会出很大问题。目前项目需要处理T2等其他几个序列的图像，尝试过使用FSL，效果不理想，现在仍然在寻找合适的预处理方法。（前几天查文献查到了一个叫<a href="https://pubmed.ncbi.nlm.nih.gov/35842095/">SynthStrip</a>[1]的去颅骨方法，使用了神经网络，据称是可以对任意脑部图像进行去颅骨，再一查发现这个工具已经在2023年初被整合进FreeSurfer了，这几天更新FreeSurfer尝试之后会再写一篇笔记记录效果。）<br>更新：用一例T2图像试了一下，SynthStrip效果确实很好！后面写个批处理把所有的图像都用这个方法处理一下看看效果，然后写篇博客记录一下！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在macOS上安装FreeSurfer的过程比较简单。首先在<a href="https://surfer.nmr.mgh.harvard.edu/fswiki/rel7downloads">官网</a>下载最新版安装包进行安装，有tar包和pkg包可选，我这里选用<strong>pkg</strong>安装包。软件比较大，需要提前在电脑上预留二三十个G左右。下载完成后直接双击打开，按提示进行安装。</p><h3 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h3><p>使用FreeSurfer之前需要去官网申请一个许可证。这个许可证是免费的，据官方说法主要是为了统计软件使用情况。<a href="https://surfer.nmr.mgh.harvard.edu/registration.html">前往这个链接</a>填写好申请表就可以申请到许可证了。最后有一个reCAPTCHA验证，如果加载不出来可能需要科学上网。获得许可证之后把许可证扔到FreeSurfer根目录下（<code>/Applications/freesurfer/&lt;你安装的FreeSurfer版本,可以用Finder去看一下实际路径&gt;</code>）就可以了。</p><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>安装完成后，需要设置一下环境变量。在终端中输入下列命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ <span class="hljs-built_in">export</span> <span class="hljs-attribute">FREESURFER_HOME</span>=/Applications/freesurfer/&lt;你安装的FreeSurfer版本,可以用Finder去看一下实际路径&gt;<br>$ <span class="hljs-built_in">export</span> <span class="hljs-attribute">SUBJECTS_DIR</span>=<span class="hljs-variable">$FREESURFER_HOME</span>/subjects<br>$ source <span class="hljs-variable">$FREESURFER_HOME</span>/SetUpFreeSurfer.sh<br><br></code></pre></td></tr></table></figure><p>这时应该会看到类似下面的输出(版本号可能不同):</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">-------- freesurfer-darwin-macOS-<span class="hljs-number">7.1</span>.<span class="hljs-number">1</span>-<span class="hljs-number">20200429</span>-<span class="hljs-number">3</span>a03ebd --------<br>Setting up environment <span class="hljs-keyword">for</span> FreeSurfer/FS-FAST (and FSL)<br>WARNING: <span class="hljs-regexp">/Users/</span>synpro<span class="hljs-regexp">/freesurfer/</span>fsfast does not exist<br>FREESURFER_HOME   <span class="hljs-regexp">/Applications/</span>freesurfer/<span class="hljs-number">7.1</span>.<span class="hljs-number">1</span><br>FSFAST_HOME       <span class="hljs-regexp">/Users/</span>synpro<span class="hljs-regexp">/freesurfer/</span>fsfast<br>FSF_OUTPUT_FORMAT nii.gz<br>SUBJECTS_DIR      <span class="hljs-regexp">/Applications/</span>freesurfer<span class="hljs-regexp">/7.1.1/</span>su<br></code></pre></td></tr></table></figure><p>这时输入<code>which freeview</code>，如果返回正确的FreeView路径（类似<code>/Applications/freesurfer/7.1.1/bin/freeview</code>）说明安装成功。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>根据FreeSurfer<a href="https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all#StepDescriptionSummaries">官方文档</a>，当前版本中 recon-all 共有以下31个步骤：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Autorecon Processing Stages (see -autorecon# flags above):<br><span class="hljs-bullet">1.</span> Motion Correction and Conform<br><span class="hljs-bullet">2.</span> NU (Non-Uniform intensity normalization)<br><span class="hljs-bullet">3.</span> Talairach transform computation<br><span class="hljs-bullet">4.</span> Intensity Normalization 1<br><span class="hljs-bullet">5.</span> Skull Strip<br><span class="hljs-bullet">6.</span> EM Register (linear volumetric registration)<br><span class="hljs-bullet">7.</span> The CA Intensity Normalization<br><span class="hljs-bullet">8.</span> CA Non-linear Volumetric Registration<br><span class="hljs-bullet">9.</span> Remove Neck<br><span class="hljs-bullet">10.</span> LTA with Skull<br><span class="hljs-bullet">11.</span> CA Label (Volumetric Labeling, ie Aseg) and Statistics<br><span class="hljs-bullet">12.</span> Intensity Normalization 2 (start here for control points)<br><span class="hljs-bullet">13.</span> White matter segmentation<br><span class="hljs-bullet">14.</span> Edit WM With ASeg<br><span class="hljs-bullet">15.</span> Fill (start here for wm edits)<br><span class="hljs-bullet">16.</span> Tessellation (begins per-hemisphere operations)<br><span class="hljs-bullet">17.</span> Smooth1<br><span class="hljs-bullet">18.</span> Inflate1<br><span class="hljs-bullet">19.</span> QSphere<br><span class="hljs-bullet">20.</span> Automatic Topology Fixer<br><span class="hljs-bullet">21.</span> Final Surfs (start here for brain edits for pial surf)<br><span class="hljs-bullet">22.</span> Smooth2<br><span class="hljs-bullet">23.</span> Inflate2<br><span class="hljs-bullet">24.</span> Spherical Mapping<br><span class="hljs-bullet">25.</span> Spherical Registration<br><span class="hljs-bullet">26.</span> Spherical Registration, Contralateral hemisphere<br><span class="hljs-bullet">27.</span> Map average curvature to subject<br><span class="hljs-bullet">28.</span> Cortical Parcellation - Desikan-Killiany and Christophe (Labeling)<br><span class="hljs-bullet">29.</span> Cortical Parcellation Statistics<br><span class="hljs-bullet">30.</span> Cortical Ribbon Mask<br><span class="hljs-bullet">31.</span> Cortical Parcellation mapping to Aseg<br></code></pre></td></tr></table></figure><p>同时 <code>recon-all</code> 提供了<code>-autorecon1</code> 参数，使用该参数时只执行步骤1-5，刚好满足我们的需求。recon-all还有许多其他的参数，具体可以参考官方文档中<a href="https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all#StepDescriptionSummaries">介绍recon-all的部分</a>。</p><p>运行<code>recon-all</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">recon-all -s &lt;输出路径&gt; -i &lt;nii或dcm文件, 如<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/nii/my</span>_nii_file.nii.gz&gt; -autorecon1<br><br></code></pre></td></tr></table></figure><p>运行完成后，为这个病例生成的所有文件都可以在输出路径中找到。我们主要用mri文件夹内的文件。查询文档得知，去颅骨后的结果被保存在<code>mri/brainmask.auto.mgz</code>文件中。可以运行<code>mri_convert brainmask.auto.mgz result.nii</code>将文件转换回nii文件。注意此时的图像的大小已经变为<code>256*256*256</code>。</p><p>[1] Hoopes A, Mora JS, Dalca AV, Fischl B, Hoffmann M. SynthStrip: skull-stripping for any brain image. Neuroimage. 2022 Oct 15;260:119474. doi: 10.1016&#x2F;j.neuroimage.2022.119474. Epub 2022 Jul 13. PMID: 35842095; PMCID: PMC9465771.</p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中文</tag>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读速记-Deep Learning With Data Enhancement for the Differentiation of Solitary and Multiple Cerebral Glioblastoma, Lymphoma, and Tumefactive Demyelinating Lesion</title>
    <link href="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/"/>
    <url>/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/</url>
    
    <content type="html"><![CDATA[<h2 id="Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion"><a href="#Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion" class="headerlink" title="Deep Learning With Data Enhancement for the Differentiation of Solitary and Multiple Cerebral Glioblastoma, Lymphoma, and Tumefactive Demyelinating Lesion"></a>Deep Learning With Data Enhancement for the Differentiation of Solitary and Multiple Cerebral Glioblastoma, Lymphoma, and Tumefactive Demyelinating Lesion</h2><h3 id="论文作者-Zhang-et-al"><a href="#论文作者-Zhang-et-al" class="headerlink" title="论文作者: Zhang et al."></a>论文作者: Zhang <em>et al.</em></h3><ul><li>GBM胶质瘤, PCNSL淋巴瘤, TDL瘤样脱髓鞘损伤</li></ul><h2 id="结论：Deep-learning-with-data-enhancement-is-useful-for-the-accurate-identification-of-GBM-PCNSL-and-TDL-and-its-diagnostic-performance-is-better-than-that-of-the-neuroradiologists"><a href="#结论：Deep-learning-with-data-enhancement-is-useful-for-the-accurate-identification-of-GBM-PCNSL-and-TDL-and-its-diagnostic-performance-is-better-than-that-of-the-neuroradiologists" class="headerlink" title="结论：Deep learning with data enhancement is useful for the accurate identification of GBM, PCNSL, and TDL, and its diagnostic performance is better than that of the neuroradiologists."></a>结论：Deep learning with data enhancement is useful for the accurate identification of GBM, PCNSL, and TDL, and its diagnostic performance is better than that of the neuroradiologists.</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>The open-ring enhancement in TDL may be an important sign that distinguishes it from other tumors</li></ul><h3 id="现有研究：These-advanced-MR-modalities-mainly-focused-only-on-the-enhanced-component-of-the-lesion"><a href="#现有研究：These-advanced-MR-modalities-mainly-focused-only-on-the-enhanced-component-of-the-lesion" class="headerlink" title="现有研究：These advanced MR modalities mainly focused only on the enhanced component of the lesion."></a>现有研究：These advanced MR modalities mainly focused only on the enhanced component of the lesion.</h3><ul><li><p>Another study reported that diffusion-weighted imaging (DWI) could be a useful diagnostic tool to differentiate among PCNSL, GBM, and inflammatory demyelination pseudotumor (10).</p></li><li><p>MRS had been a valuable approach to distinguish the mimicked pathologies (11).</p></li></ul><h3 id="现有研究：Radiomics-based-analysis-can-explore-the-whole-lesion-including-the-enhanced-and-non-enhanced-components"><a href="#现有研究：Radiomics-based-analysis-can-explore-the-whole-lesion-including-the-enhanced-and-non-enhanced-components" class="headerlink" title="现有研究：Radiomics-based analysis can explore the whole lesion including the enhanced and non-enhanced components."></a>现有研究：Radiomics-based analysis can explore the whole lesion including the enhanced and non-enhanced components.</h3><ul><li>For example, the deep learning approach has been used for the differential diagnosis or grading in meningioma (12–14).</li></ul><h2 id="Materials-and-Methods"><a href="#Materials-and-Methods" class="headerlink" title="Materials and Methods"></a>Materials and Methods</h2><ul><li><p>样本：97, 92, and 72 patients with GBM胶质瘤, PCNSL淋巴瘤, and TDL瘤样脱髓鞘损伤</p></li><li><p>数据集：The MRI acquisition protocols were composed of pre- and post- enhanced T1-weighted (CE-T1) images. （Supplementary File 2）<br><a href="https://www.frontiersin.org/articles/10.3389/fonc.2021.665891/full#supplementary-material">https://www.frontiersin.org/articles/10.3389/fonc.2021.665891/full#supplementary-material</a></p></li><li><p>预处理（分割 Region of Interest）： All MR images in the form of digital imaging and communications in medicine (DICOM) were input to the ITK- SNAP (version 3.4.0, <a href="http://www.itk-snap.org/">www.itk-snap.org</a>). The regions of interest (ROIs) of these three types of lesions were manually delineated on axial CE-T1 by a neuroradiologist using ITK-SNAP.</p></li><li><p>数据处理前请了两位10年经验神经外科医生进行了诊断，以便后续对比机器学习的性能</p></li></ul><h3 id="Algorithm-Implementation-分为三个步骤"><a href="#Algorithm-Implementation-分为三个步骤" class="headerlink" title="Algorithm Implementation: 分为三个步骤"></a>Algorithm Implementation: 分为三个步骤</h3><ul><li><p>The 261 subjects were randomly divided into a training set and a testing set.</p></li><li><p>All data were converted into a NIFTI format to adapt to a 3D network.</p></li><li><p>The diagnosis process is presented in Figure 1. It was divided into three stages and was not an end-to-end solution.<br><img src="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/figure1.png" alt="Figure 1"></p></li></ul><h3 id="第一个步骤：3D-U-Net"><a href="#第一个步骤：3D-U-Net" class="headerlink" title="第一个步骤：3D U-Net"></a>第一个步骤：3D U-Net</h3><ul><li><p>First, MRI was <em><strong>cropped</strong></em> to reduce the consumption of computing resources, and then the data were <em><strong>normalized</strong></em> to reduce the interference of medical image caused by uneven light.</p></li><li><p>The initial input network image size was reduced to <em><strong>128 × 128 × 32</strong></em> without affecting the segmentation performance.</p></li><li><p>entered to a convolution layer and four ResBlock downsampling modules -&gt; the features obtained after the fourth downsampling were fused with the features obtained after the third downsampling module -&gt; the fused features were entered into the upsampling ResBlock module to obtain the upsampling features. -&gt; the image size was finally restored to 128 × 128 × 32</p></li><li><p>Finally, the number of channels were reduced to two after the image entered a convolution layer.</p></li><li><p>The segmentation mask was obtained by argmax function, and the segmentation mask was restored to 512 × 512 × 24 by bilinear interpolation.</p></li></ul><h3 id="第二个步骤：数据增强"><a href="#第二个步骤：数据增强" class="headerlink" title="第二个步骤：数据增强"></a>第二个步骤：数据增强</h3><ul><li>把分割下来的病灶部分以一定倍数叠加到原图上</li><li>In the second stage, the segmented lesion area was combined with the original MR image to change the pixels of the lesion area by a certain multiple, and the pixels of the non-lesion area were unchanged. The following combination equation was used:<br>Mn &#x3D; M + M • n • k<br>Mn: enhanced data<br>M: original MRI<br>n: segmented mask<br>k: enhancement coefficient  </li><li>In this experiment, five k values were selected, namely, −0.5, 0, 0.5, 1, and 2, to explore the best model. <img src="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/figure2.png" alt="Figure 2"></li></ul><h3 id="第三个步骤：3D-Resnet18"><a href="#第三个步骤：3D-Resnet18" class="headerlink" title="第三个步骤：3D Resnet18"></a>第三个步骤：3D Resnet18</h3><ul><li><p>In the third stage, the enhanced data were preprocessed similar to the first stage.</p></li><li><p>Resnet 18 识别 GBM, PCNSL, and TDL.</p></li><li><p>分别尝试了 k &#x3D; −0.5, 0, 0.5, 1, 2与单独使用损伤区域进行识别</p></li><li><p><img src="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/figure3.png" alt="20220519_111315_71"></p></li></ul><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul><li><p>The diagnostic performance fluctuated with the ratio of lesion to non-lesion area changed. The diagnostic performance was best when the ratio was 1.5. The AUCs of GBM, PCNSL, and TDL were 1.00 (95% confidence interval [CI]: 1.000–1.000), 0.96 (95% CI: 0.923–1.000), and 0.954 (95% CI: 0.904–1.000), respectively.</p></li><li><p>The AUC (95% confidence interval [CI]), accuracy, sensitivity, specificity, and overall accuracy are presented in Tables 2 and 3. The ROC curves are shown in Figure 4. <em><strong>When k was 0.5, the diagnostic performance was the best, and the overall accuracy was 92.4%. The AUC (95% CI) of GBM, PCNSL, and TDL were 1.00 (1.000–1.000), 0.96 (0.923–1.000), and 0.95 (0.904–1.000), respectively.</strong></em> The selected radiomics features of GBM, PCNSL, and TDL at the optimal k value are shown in Figure 5. The overall diagnostic performances of the two neuroradiologists were 52.4%.</p></li><li><p><img src="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/table2_3.png" alt="20220519_114606_16"></p></li><li><p><img src="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/figure4.png" alt="20220519_114041_62"></p></li><li><p><img src="/2022/05/19/notes-paper-Deep-Learning-With-Data-Enhancement-for-the-Differentiation-of-Solitary-and-Multiple-Cerebral-Glioblastoma-Lymphoma-and-Tumefactive-Demyelinating-Lesion/figure5.png" alt="20220519_114631_98"></p></li><li><p>创新点：To our knowledge, our study is the first to simultaneously differentiate the three entities with solitary and multifocal types by radiomics analysis.</p></li><li><p>数据增强：准确率随病灶区域与非病灶区域占比提高先上升后下降，存在一个最优点，这时病灶区域和非病灶区域都包含了对识别有用的信息</p></li></ul><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li><p>there may be some selection bias  </p></li><li><p>not end-to-end: this makes it more challenging for non-professionals to use this diagnostic method.<br>Although we tried to use the end-to-end network for training, the existing data could not support training several times larger than the existing model to achieve better diagnostic performance.<br>Therefore, more data need to be collected to support end-to-end networks.</p></li><li><p>this experiment only studied the differentiation of three radiologically similar lesions; neuroradiologists may consider additional diseases when making a diagnosis.<br>The existing supervised machine learning and deep learning methods can only diagnose the disease as one of the training set labels, and ignore other possible diseases.  </p></li><li><p>no external validation was performed.</p></li><li><p><em><strong>only single-mode MRI data were used in this study.</strong></em><br>Inclusion of multimodal data will provide more diagnostic information and is one of the important ways to improve diagnostic performance.<br>However, the single-model data reduce the difficulty of data collection, which makes our method more easily applicable to other diagnosis processes than other methods.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像处理</tag>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脑瘤相关论文笔记</title>
    <link href="/2022/05/19/brain-tumor-starter/"/>
    <url>/2022/05/19/brain-tumor-starter/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习领域"><a href="#机器学习领域" class="headerlink" title="机器学习领域"></a>机器学习领域</h2><ol><li><p><em><strong>Deep Learning With Data Enhancement for the Differentiation of Solitary and Multiple Cerebral Glioblastoma, Lymphoma, and Tumefactive Demyelinating Lesion</strong></em> <a href="./Deep_Learning_With_Data_Enhancement_for_the_Differentiation_of_Solitary_and_Multiple_Cerebral_Glioblastoma_Lymphoma_and_Tumefactive_Demyelinating_Lesion/notes.pdf">详细笔记</a></p></li><li><p>Differentiating Primary Central Nervous System Lymphomas From Glioblastomas and Inflammatory Demyelinating Pseudotumor Using Relative Minimum Apparent Diffusion Coefficients<br>为1引用的文章，从标题看也是区分淋巴瘤、胶质瘤和瘤样脱髓鞘病</p></li><li><p>Detection of pseudo brain tumors via stacked LSTM neural networks using MR spectroscopy signals.pdf 使用的是MRS   </p></li><li><p>Performance of machine learning algorithms for glioma segmentation of brain MRI: a systematic literature review and meta-analysis 综述，被引量只有4</p></li><li><p>Brain_Tumor_Segmentation_Using_Convolutional_Neural_Networks_in_MRI_Images 引用量很高，有点老  </p></li><li><p>N4ITK_Improved_N3_Bias_Correction N4ITK预处理方法</p></li></ol><h3 id="脑瘤分类"><a href="#脑瘤分类" class="headerlink" title="脑瘤分类"></a>脑瘤分类</h3><ul><li>待补充</li></ul><h3 id="脑瘤分割-BraTS-：一些其他的BraTS-Challenge的论文"><a href="#脑瘤分割-BraTS-：一些其他的BraTS-Challenge的论文" class="headerlink" title="脑瘤分割(BraTS)：一些其他的BraTS Challenge的论文"></a>脑瘤分割(BraTS)：一些其他的BraTS Challenge的论文</h3><p>有3D 2D 2.5D，以使用3D CNN居多</p><ol><li><p>Efficient multi-scale 3D CNN with fully connected CRF for accurate brain lesion segmentation 被引量很高，使用3D CNN，使用CRF作为后处理  </p></li><li><p>Automatic Brain Tumor Segmentation Based on Cascaded Convolutional Neural Networks With Uncertainty Estimation 多个网络处理统一张图片，分别识别肿瘤，tumor core 和enhanced core 使用2.5D CNN</p></li><li><p>Machine Learning Based Brain Tumour Segmentation on Limited Data Using Local Textture and Abnormality 提到了预处理，统计数据集情况后发现不是所有人都有T2，因此使用T1ce 和 FLAIR  </p></li><li><p>A_Modified_U-Net_Convolutional_Network_Featuring_a_Nearest-neighbor_Re-sampling-based_Elastic-Transformation_for_Brain_Tissue_Characterization_and_Segmentation 使用了UNet</p></li></ol><h3 id="脑瘤分割"><a href="#脑瘤分割" class="headerlink" title="脑瘤分割"></a>脑瘤分割</h3><ol><li><p>Low-Grade Glioma Segmentation Based on CNN with Fully Connected CRF 自有数据集 上海华山医院 关注LGG的识别，发现LGG在T2 FLAIR中更有辨识度，因此使用T2 FLAIR 3DCNN+3DCRF  </p></li><li><p>Clinical Evaluation of a Multiparametric Deep Learning Model for Glioblastoma Segmentation Using Heterogeneous Magnetic Resonance Imaging Data From Clinical Routine 3DCNN+3DCRF 预处理：bias field correction +  T1w, T2w, and FLAIR coregisered to reference space defined by T1CE</p></li></ol><h2 id="医学领域"><a href="#医学领域" class="headerlink" title="医学领域"></a>医学领域</h2><ol><li>Cerebral tumor or pseudotumor<br>关于如何分辨脑瘤与炎性假瘤, T2似乎比较重要</li></ol><ul><li>Demyelinating lesions can present a pseudotumoral appearance related to a significant inflammatory reaction, with hyperT2 areas appearing extensive, more than 2cm in diameter.</li><li>Lesions appear in T2 isosignal or hypersignal.</li><li>Some MRI signs：<ul><li>no or little mass effect compared with the size of the lesion</li><li>an incomplete ring enhancement, with in particular, “C-shape” enhancement of a sub-cortical lesions</li><li>a peripheral border with restricted diffusion consistent with a demyelinating front and the presence of a normal vessel within the lesion traducing the venular tropism of the lesions (more visible after injection or in magnetic susceptibility imaging)</li></ul></li></ul><h3 id="TIDD"><a href="#TIDD" class="headerlink" title="TIDD"></a>TIDD</h3><ol><li>Intracranial Demyelinating Pseudotumor_A Case Report and Review of the Literature</li></ol><ul><li>Unlike astrocytoma, demyelinating pseudotumor is often accompanied with light edema and less mass effect, which can be observed on CT and MRI scans;</li><li>Lesion enhancements of demyelinating pseudotumor tend to be perpendicular to the surface of the lateral ventricle;</li></ul>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中文</tag>
      
      <tag>医学图像处理</tag>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
